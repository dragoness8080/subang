package com.gcs.suban.tools;

import java.io.File;
import java.math.BigDecimal;

import android.content.Context;
import android.os.Environment;
import android.text.TextUtils;
import android.util.Log;

/** * 本应用数据清除管理器 */
public class DataCleanManager {
	
	 public static String getTotalCacheSize(Context context) throws Exception {
	    	long cacheSize = getFolderSize(context.getCacheDir());
	    	if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {  
	    		cacheSize += getFolderSize(context.getExternalCacheDir());
	        }  
	    	return getFormatSize(cacheSize);
	    }
 
 
   public static void clearAllCache(Context context) {
   	deleteDir(context.getCacheDir());
   	if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {  
   		deleteDir(context.getExternalCacheDir());
       }  
   }
 
   private static boolean deleteDir(File dir) {
       if (dir != null && dir.isDirectory()) {
           String[] children = dir.list();
           for (int i = 0; i < children.length; i++) {
               boolean success = deleteDir(new File(dir, children[i]));
               if (!success) {
                   return false;
               }
           }
       }
       return dir.delete();
   }
     
   // 获取文件  
   //Context.getExternalFilesDir() --> SDCard/Android/data/你的应用的包名/files/ 目录，一般放一些长时间保存的数据  
   //Context.getExternalCacheDir() --> SDCard/Android/data/你的应用包名/cache/目录，一般存放临时缓存数据  
   public static long getFolderSize(File file) throws Exception {  
       long size = 0;  
       try {  
           File[] fileList = file.listFiles();  
           for (int i = 0; i < fileList.length; i++) {  
               // 如果下面还有文件  
               if (fileList[i].isDirectory()) {  
                   size = size + getFolderSize(fileList[i]);  
               } else {  
                   size = size + fileList[i].length();  
               }  
           }  
       } catch (Exception e) {  
           e.printStackTrace();  
       }  
       return size;  
   }  
     
   /** 
    * 格式化单位 
    *  
    * @param size 
    * @return 
    */  
   public static String getFormatSize(double size) {  
       double kiloByte = size / 1024;  
       if (kiloByte < 1) {  
//           return size + "Byte";  
       	return "0K";
       }  
 
       double megaByte = kiloByte / 1024;  
       if (megaByte < 1) {  
           BigDecimal result1 = new BigDecimal(Double.toString(kiloByte));  
           return result1.setScale(2, BigDecimal.ROUND_HALF_UP)  
                   .toPlainString() + "KB";  
       }  
 
       double gigaByte = megaByte / 1024;  
       if (gigaByte < 1) {  
           BigDecimal result2 = new BigDecimal(Double.toString(megaByte));  
           return result2.setScale(2, BigDecimal.ROUND_HALF_UP)  
                   .toPlainString() + "MB";  
       }  
 
       double teraBytes = gigaByte / 1024;  
       if (teraBytes < 1) {  
           BigDecimal result3 = new BigDecimal(Double.toString(gigaByte));  
           return result3.setScale(2, BigDecimal.ROUND_HALF_UP)  
                   .toPlainString() + "GB";  
       }  
       BigDecimal result4 = new BigDecimal(teraBytes);  
       return result4.setScale(2, BigDecimal.ROUND_HALF_UP).toPlainString()  
               + "TB";  
   }  
   
   
   /**
    * 获取应用专属缓存目录
    * android 4.4及以上系统不需要申请SD卡读写权限
    * 因此也不用考虑6.0系统动态申请SD卡读写权限问题，切随应用被卸载后自动清空 不会污染用户存储空间
    * @param context 上下文
    * @param type 文件夹类型 可以为空，为空则返回API得到的一级目录
    * @return 缓存文件夹 如果没有SD卡或SD卡有问题则返回内存缓存目录，否则优先返回SD卡缓存目录
    */
   public static File getCacheDirectory(Context context,String type) {
       File appCacheDir = getExternalCacheDirectory(context,type);
       if (appCacheDir == null){
           appCacheDir = getInternalCacheDirectory(context,type);
       }

       if (appCacheDir == null){
           Log.e("getCacheDirectory","getCacheDirectory fail ,the reason is mobile phone unknown exception !");
       }else {
           if (!appCacheDir.exists()&&!appCacheDir.mkdirs()){
               Log.e("getCacheDirectory","getCacheDirectory fail ,the reason is make directory fail !");
           }
       }
       return appCacheDir;
   }

   /**
    * 获取SD卡缓存目录
    * @param context 上下文
    * @param type 文件夹类型 如果为空则返回 /storage/emulated/0/Android/data/app_package_name/cache
    *             否则返回对应类型的文件夹如Environment.DIRECTORY_PICTURES 对应的文件夹为 .../data/app_package_name/files/Pictures
    * {@link android.os.Environment#DIRECTORY_MUSIC},
    * {@link android.os.Environment#DIRECTORY_PODCASTS},
    * {@link android.os.Environment#DIRECTORY_RINGTONES},
    * {@link android.os.Environment#DIRECTORY_ALARMS},
    * {@link android.os.Environment#DIRECTORY_NOTIFICATIONS},
    * {@link android.os.Environment#DIRECTORY_PICTURES}, or
    * {@link android.os.Environment#DIRECTORY_MOVIES}.or 自定义文件夹名称
    * @return 缓存目录文件夹 或 null（无SD卡或SD卡挂载失败）
    */
   public static File getExternalCacheDirectory(Context context,String type) {
       File appCacheDir = null;
       if( Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) {
           if (TextUtils.isEmpty(type)){
               appCacheDir = context.getExternalCacheDir();
           }else {
               appCacheDir = context.getExternalFilesDir(type);
           }

           if (appCacheDir == null){// 有些手机需要通过自定义目录
               appCacheDir = new File(Environment.getExternalStorageDirectory(),"Android/data/"+context.getPackageName()+"/cache/"+type);
           }

           if (!appCacheDir.exists()&&!appCacheDir.mkdirs()){
		       Log.e("getExternalDirectory","getExternalDirectory fail ,the reason is make directory fail !");
		   }
       }else {
           Log.e("getExternalDirectory","getExternalDirectory fail ,the reason is sdCard nonexistence or sdCard mount fail !");
       }
       return appCacheDir;
   }

   /**
    * 获取内存缓存目录
    * @param type 子目录，可以为空，为空直接返回一级目录
    * @return 缓存目录文件夹 或 null（创建目录文件失败）
    * 注：该方法获取的目录是能供当前应用自己使用，外部应用没有读写权限，如 系统相机应用
    */
   public static File getInternalCacheDirectory(Context context,String type) {
       File appCacheDir = null;
       if (TextUtils.isEmpty(type)){
           appCacheDir = context.getCacheDir();// /data/data/app_package_name/cache
       }else {
           appCacheDir = new File(context.getFilesDir(),type);// /data/data/app_package_name/files/type
       }

       if (!appCacheDir.exists()&&!appCacheDir.mkdirs()){
           Log.e("getInternalDirectory","getInternalDirectory fail ,the reason is make directory fail !");
       }
       return appCacheDir;
   }
     
}